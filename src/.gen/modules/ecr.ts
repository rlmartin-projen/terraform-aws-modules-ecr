// generated by cdktf get
// terraform-aws-modules/ecr/aws
import { TerraformModule, TerraformModuleUserConfig } from 'cdktf';
import { Construct } from 'constructs';
export interface EcrConfig extends TerraformModuleUserConfig {
  /**
   * Determines whether a repository policy will be attached to the repository
   * @default true
   */
  readonly attachRepositoryPolicy?: boolean;
  /**
   * Determines whether resources will be created (affects all resources)
   * @default true
   */
  readonly create?: boolean;
  /**
   * Determines whether a lifecycle policy will be created
   * @default true
   */
  readonly createLifecyclePolicy?: boolean;
  /**
   * Determines whether a registry policy will be created
   */
  readonly createRegistryPolicy?: boolean;
  /**
   * Determines whether a registry replication configuration will be created
   */
  readonly createRegistryReplicationConfiguration?: boolean;
  /**
   * Determines whether a repository will be created
   * @default true
   */
  readonly createRepository?: boolean;
  /**
   * Determines whether a repository policy will be created
   * @default true
   */
  readonly createRepositoryPolicy?: boolean;
  /**
   * Determines whether the registry scanning configuration will be managed
   */
  readonly manageRegistryScanningConfiguration?: boolean;
  /**
   * Catalog data configuration for the repository
   * @default [object Object]
   */
  readonly publicRepositoryCatalogData?: any;
  /**
   * The policy document. This is a JSON formatted string
   */
  readonly registryPolicy?: string;
  /**
   * List of pull through cache rules to create
   * @default [object Object]
   * The property type contains a map, they have special handling, please see {@link cdk.tf/module-map-inputs the docs}
   */
  readonly registryPullThroughCacheRules?: { [key: string]: { [key: string]: string } };
  /**
   * The replication rules for a replication configuration. A maximum of 10 are allowed
   * @default 
   */
  readonly registryReplicationRules?: any;
  /**
   * One or multiple blocks specifying scanning rules to determine which repository filters are used and at what frequency scanning will occur
   * @default 
   */
  readonly registryScanRules?: any;
  /**
   * the scanning type to set for the registry. Can be either `ENHANCED` or `BASIC`
   * @default ENHANCED
   */
  readonly registryScanType?: string;
  /**
   * The encryption type for the repository. Must be one of: `KMS` or `AES256`. Defaults to `AES256`
   */
  readonly repositoryEncryptionType?: string;
  /**
   * If `true`, will delete the repository even if it contains images. Defaults to `false`
   */
  readonly repositoryForceDelete?: boolean;
  /**
   * Indicates whether images are scanned after being pushed to the repository (`true`) or not scanned (`false`)
   * @default true
   */
  readonly repositoryImageScanOnPush?: boolean;
  /**
   * The tag mutability setting for the repository. Must be one of: `MUTABLE` or `IMMUTABLE`. Defaults to `IMMUTABLE`
   * @default IMMUTABLE
   */
  readonly repositoryImageTagMutability?: string;
  /**
   * The ARN of the KMS key to use when encryption_type is `KMS`. If not specified, uses the default AWS managed key for ECR
   */
  readonly repositoryKmsKey?: string;
  /**
   * The ARNs of the Lambda service roles that have read access to the repository
   * @default 
   */
  readonly repositoryLambdaReadAccessArns?: string[];
  /**
   * The policy document. This is a JSON formatted string. See more details about [Policy Parameters](http://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html#lifecycle_policy_parameters) in the official AWS docs
   */
  readonly repositoryLifecyclePolicy?: string;
  /**
   * The name of the repository
   */
  readonly repositoryName?: string;
  /**
   * The JSON policy to apply to the repository. If not specified, uses the default policy
   */
  readonly repositoryPolicy?: string;
  /**
   * The ARNs of the IAM users/roles that have read access to the repository
   * @default 
   */
  readonly repositoryReadAccessArns?: string[];
  /**
   * The ARNs of the IAM users/roles that have read/write access to the repository
   * @default 
   */
  readonly repositoryReadWriteAccessArns?: string[];
  /**
   * The type of repository to create. Either `public` or `private`
   * @default private
   */
  readonly repositoryType?: string;
  /**
   * A map of tags to add to all resources
   * @default [object Object]
   * The property type contains a map, they have special handling, please see {@link cdk.tf/module-map-inputs the docs}
   */
  readonly tags?: { [key: string]: string };
}
/**
 * Defines an Ecr based on a Terraform module
 *
 * Docs at Terraform Registry: {@link https://registry.terraform.io/modules/terraform-aws-modules/ecr/aws/~> 1.0 terraform-aws-modules/ecr/aws}
 */
export class Ecr extends TerraformModule {
  private readonly inputs: { [name: string]: any } = { }
  public constructor(scope: Construct, id: string, config: EcrConfig = {}) {
    super(scope, id, {
      ...config,
      source: 'terraform-aws-modules/ecr/aws',
      version: '~> 1.0',
    });
    this.attachRepositoryPolicy = config.attachRepositoryPolicy;
    this.create = config.create;
    this.createLifecyclePolicy = config.createLifecyclePolicy;
    this.createRegistryPolicy = config.createRegistryPolicy;
    this.createRegistryReplicationConfiguration = config.createRegistryReplicationConfiguration;
    this.createRepository = config.createRepository;
    this.createRepositoryPolicy = config.createRepositoryPolicy;
    this.manageRegistryScanningConfiguration = config.manageRegistryScanningConfiguration;
    this.publicRepositoryCatalogData = config.publicRepositoryCatalogData;
    this.registryPolicy = config.registryPolicy;
    this.registryPullThroughCacheRules = config.registryPullThroughCacheRules;
    this.registryReplicationRules = config.registryReplicationRules;
    this.registryScanRules = config.registryScanRules;
    this.registryScanType = config.registryScanType;
    this.repositoryEncryptionType = config.repositoryEncryptionType;
    this.repositoryForceDelete = config.repositoryForceDelete;
    this.repositoryImageScanOnPush = config.repositoryImageScanOnPush;
    this.repositoryImageTagMutability = config.repositoryImageTagMutability;
    this.repositoryKmsKey = config.repositoryKmsKey;
    this.repositoryLambdaReadAccessArns = config.repositoryLambdaReadAccessArns;
    this.repositoryLifecyclePolicy = config.repositoryLifecyclePolicy;
    this.repositoryName = config.repositoryName;
    this.repositoryPolicy = config.repositoryPolicy;
    this.repositoryReadAccessArns = config.repositoryReadAccessArns;
    this.repositoryReadWriteAccessArns = config.repositoryReadWriteAccessArns;
    this.repositoryType = config.repositoryType;
    this.tags = config.tags;
  }
  public get attachRepositoryPolicy(): boolean | undefined {
    return this.inputs['attach_repository_policy'] as boolean | undefined;
  }
  public set attachRepositoryPolicy(value: boolean | undefined) {
    this.inputs['attach_repository_policy'] = value;
  }
  public get create(): boolean | undefined {
    return this.inputs['create'] as boolean | undefined;
  }
  public set create(value: boolean | undefined) {
    this.inputs['create'] = value;
  }
  public get createLifecyclePolicy(): boolean | undefined {
    return this.inputs['create_lifecycle_policy'] as boolean | undefined;
  }
  public set createLifecyclePolicy(value: boolean | undefined) {
    this.inputs['create_lifecycle_policy'] = value;
  }
  public get createRegistryPolicy(): boolean | undefined {
    return this.inputs['create_registry_policy'] as boolean | undefined;
  }
  public set createRegistryPolicy(value: boolean | undefined) {
    this.inputs['create_registry_policy'] = value;
  }
  public get createRegistryReplicationConfiguration(): boolean | undefined {
    return this.inputs['create_registry_replication_configuration'] as boolean | undefined;
  }
  public set createRegistryReplicationConfiguration(value: boolean | undefined) {
    this.inputs['create_registry_replication_configuration'] = value;
  }
  public get createRepository(): boolean | undefined {
    return this.inputs['create_repository'] as boolean | undefined;
  }
  public set createRepository(value: boolean | undefined) {
    this.inputs['create_repository'] = value;
  }
  public get createRepositoryPolicy(): boolean | undefined {
    return this.inputs['create_repository_policy'] as boolean | undefined;
  }
  public set createRepositoryPolicy(value: boolean | undefined) {
    this.inputs['create_repository_policy'] = value;
  }
  public get manageRegistryScanningConfiguration(): boolean | undefined {
    return this.inputs['manage_registry_scanning_configuration'] as boolean | undefined;
  }
  public set manageRegistryScanningConfiguration(value: boolean | undefined) {
    this.inputs['manage_registry_scanning_configuration'] = value;
  }
  public get publicRepositoryCatalogData(): any | undefined {
    return this.inputs['public_repository_catalog_data'] as any | undefined;
  }
  public set publicRepositoryCatalogData(value: any | undefined) {
    this.inputs['public_repository_catalog_data'] = value;
  }
  public get registryPolicy(): string | undefined {
    return this.inputs['registry_policy'] as string | undefined;
  }
  public set registryPolicy(value: string | undefined) {
    this.inputs['registry_policy'] = value;
  }
  public get registryPullThroughCacheRules(): { [key: string]: { [key: string]: string } } | undefined {
    return this.inputs['registry_pull_through_cache_rules'] as { [key: string]: { [key: string]: string } } | undefined;
  }
  public set registryPullThroughCacheRules(value: { [key: string]: { [key: string]: string } } | undefined) {
    this.inputs['registry_pull_through_cache_rules'] = value;
  }
  public get registryReplicationRules(): any | undefined {
    return this.inputs['registry_replication_rules'] as any | undefined;
  }
  public set registryReplicationRules(value: any | undefined) {
    this.inputs['registry_replication_rules'] = value;
  }
  public get registryScanRules(): any | undefined {
    return this.inputs['registry_scan_rules'] as any | undefined;
  }
  public set registryScanRules(value: any | undefined) {
    this.inputs['registry_scan_rules'] = value;
  }
  public get registryScanType(): string | undefined {
    return this.inputs['registry_scan_type'] as string | undefined;
  }
  public set registryScanType(value: string | undefined) {
    this.inputs['registry_scan_type'] = value;
  }
  public get repositoryEncryptionType(): string | undefined {
    return this.inputs['repository_encryption_type'] as string | undefined;
  }
  public set repositoryEncryptionType(value: string | undefined) {
    this.inputs['repository_encryption_type'] = value;
  }
  public get repositoryForceDelete(): boolean | undefined {
    return this.inputs['repository_force_delete'] as boolean | undefined;
  }
  public set repositoryForceDelete(value: boolean | undefined) {
    this.inputs['repository_force_delete'] = value;
  }
  public get repositoryImageScanOnPush(): boolean | undefined {
    return this.inputs['repository_image_scan_on_push'] as boolean | undefined;
  }
  public set repositoryImageScanOnPush(value: boolean | undefined) {
    this.inputs['repository_image_scan_on_push'] = value;
  }
  public get repositoryImageTagMutability(): string | undefined {
    return this.inputs['repository_image_tag_mutability'] as string | undefined;
  }
  public set repositoryImageTagMutability(value: string | undefined) {
    this.inputs['repository_image_tag_mutability'] = value;
  }
  public get repositoryKmsKey(): string | undefined {
    return this.inputs['repository_kms_key'] as string | undefined;
  }
  public set repositoryKmsKey(value: string | undefined) {
    this.inputs['repository_kms_key'] = value;
  }
  public get repositoryLambdaReadAccessArns(): string[] | undefined {
    return this.inputs['repository_lambda_read_access_arns'] as string[] | undefined;
  }
  public set repositoryLambdaReadAccessArns(value: string[] | undefined) {
    this.inputs['repository_lambda_read_access_arns'] = value;
  }
  public get repositoryLifecyclePolicy(): string | undefined {
    return this.inputs['repository_lifecycle_policy'] as string | undefined;
  }
  public set repositoryLifecyclePolicy(value: string | undefined) {
    this.inputs['repository_lifecycle_policy'] = value;
  }
  public get repositoryName(): string | undefined {
    return this.inputs['repository_name'] as string | undefined;
  }
  public set repositoryName(value: string | undefined) {
    this.inputs['repository_name'] = value;
  }
  public get repositoryPolicy(): string | undefined {
    return this.inputs['repository_policy'] as string | undefined;
  }
  public set repositoryPolicy(value: string | undefined) {
    this.inputs['repository_policy'] = value;
  }
  public get repositoryReadAccessArns(): string[] | undefined {
    return this.inputs['repository_read_access_arns'] as string[] | undefined;
  }
  public set repositoryReadAccessArns(value: string[] | undefined) {
    this.inputs['repository_read_access_arns'] = value;
  }
  public get repositoryReadWriteAccessArns(): string[] | undefined {
    return this.inputs['repository_read_write_access_arns'] as string[] | undefined;
  }
  public set repositoryReadWriteAccessArns(value: string[] | undefined) {
    this.inputs['repository_read_write_access_arns'] = value;
  }
  public get repositoryType(): string | undefined {
    return this.inputs['repository_type'] as string | undefined;
  }
  public set repositoryType(value: string | undefined) {
    this.inputs['repository_type'] = value;
  }
  public get tags(): { [key: string]: string } | undefined {
    return this.inputs['tags'] as { [key: string]: string } | undefined;
  }
  public set tags(value: { [key: string]: string } | undefined) {
    this.inputs['tags'] = value;
  }
  public get repositoryArnOutput() {
    return this.getString('repository_arn')
  }
  public get repositoryRegistryIdOutput() {
    return this.getString('repository_registry_id')
  }
  public get repositoryUrlOutput() {
    return this.getString('repository_url')
  }
  protected synthesizeAttributes() {
    return this.inputs;
  }
}
